				/*! A bounding box representes the range of an object in x,y and z */
classdoc boundingbox: 

					/// constructor
					/*! creates an empty/uninitialised bounding box */
class boundingbox:  boundingbox();

				/// bounding box extent
				/*! \return bounding box extent in x-direction*/ 
class boundingbox:  double dx() const;

				/// bounding box extent
				/*! \return bounding box extent in y-direction*/ 
class boundingbox:  double dy() const;

				/// bounding box extent
				/*! \return bounding box extent in z-direction*/ 
class boundingbox:  double dz() const;

				/// center position
				/*! \return bounding box geometric center*/ 
class boundingbox:  pos3d@ center() const;

				/// low position
				/*! \return position containing minimum x,y,z*/ 
class boundingbox:  pos3d@ p1() const;

				/// high position
				/*! \return position containing maximum x,y,z*/ 
class boundingbox:  pos3d@ p2() const;

				/// enclose a new position, this may extend the boundingbox
				/*! \param p position to enclose*/ 
class boundingbox:  void enclose(pos3d@ p);


				/*! A 2d object defined by its radius. Centered on origin. */
classdoc circle:  

				/// constructor
				/*! \param r radius of circle */
class circle:   circle(double r);

				/// radius of circle
				/*! \return radius of circle */ 
class circle:   double r() const;

				/// radius of circle
				/*! \return radius of circle */ 
class circle:   double radius() const;

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class circle:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class circle:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class circle:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class circle:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class circle:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class circle:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! A cone extends in the z-direction. 
				   By default the bottom is at origin */
classdoc cone:  

				/// constructor
				/*! \param h height of cone
					\param r1 bottom radius of cone
					\param r2 top radius of cone
					\param center true if cone is centered in z-direction */
class cone:     cone(double h, double r1, double r2, bool center=false);


				/// height of cone
				/*! \return height of cone */ 
class cone:     double h() const;

				/// height of cone
				/*! \return height of cone */ 
class cone:     double height() const;

				/// bottom radius
				/*! \return bottom radius */ 
class cone:     double r1() const;

				/// top radius
				/*! \return top radius */ 
class cone:     double r2() const;

				/// bottom radius
				/*! \return bottom radius */ 
class cone:     double radius1() const;

				/// top radius
				/*! \return top radius */ 
class cone:     double radius2() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class cone:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class cone:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class cone:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class cone:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class cone:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class cone:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/// constructor
				/*! \param size length of sides 
					\param center true if cube is centered on origin*/
class cube:     cube(double size, bool center=false);

				/// size of cube
				/*! \return side length*/ 
class cube:     double size() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class cube:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class cube:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class cube:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class cube:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class cube:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class cube;   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! A cuboid is like a cube, but with separate dimensions in x,y and z.
				   By default the cuboid touches the origin, and extends along positive x,y,z. */
classdoc cuboid:  

				/// constructor
				/*! \param dx length in x-drection 
				    \param dy length of y-direction
				    \param dz length of z-direction
					\param center true if cuboid is centered on origin */
class cuboid:   cuboid(double dx, double dy, double dz, bool center=false);

                /// length in x-drection 
				/*! \return length in x-drection */
class cuboid:   double dx() const;

                /// length in y-drection 
				/*! \return length in x-drection */
class cuboid:   double dy() const;

                /// length in z-drection 
				/*! \return length in x-drection */
class cuboid:   double dz() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class cuboid:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class cuboid:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class cuboid:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class cuboid:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class cuboid:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class cuboid:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! A cylinder is defined by height and radius.
				   By default the cuboid extends from the origin, in z-direction. */
classdoc cylinder:  

				/// constructor
				/*! \param h height of cylinder
				    \param r radius of cylinder
					\param center true if cylinder is centered on origin in z-direction */
class cylinder:   cylinder(double h, double r, bool center=false);

                /// Height of cylnder
				/*! \return height of cylnder */
class cylinder:   double h() const;

                /// Height of cylnder
				/*! \return height of cylnder */
class cylinder:   double height() const;

                /// Radius of cylnder
				/*! \return radius of cylnder */
class cylinder:   double r() const;

                /// Radius of cylnder
				/*! \return radius of cylnder */
class cylinder:   double radius() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class cylinder:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class cylinder:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class cylinder:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class cylinder:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class cylinder:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class cylinder:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! difference2d is a 2-dimensional boolean operation. It can be invoked either 	
				   explicitly or using subtraction operator:
				   \n\n explicit: shape2d@ object = difference2d(circle(100),circle(50));
				   \n\n using subtraction operator: shape2d@ object = circle(100) - circle(50);
			    */
classdoc difference2d:  


				/// constructor
				/*! \param incl array of objects to be included
				    \param excl array of objects to be excluded (subtracted) */
class difference2d:   difference2d(array<shape2d@>@ incl, array<shape2d@>@ excl);

				/// constructor
				/*! \param incl array of objects to be included
				    \param excl object to be excluded (subtracted) */
class difference2d:   difference2d(array<shape2d@>@ incl, shape2d@ excl);

				/// constructor
				/*! \param incl object to be included
				    \param excl array of objects to be excluded (subtracted) */
class difference2d:   difference2d(shape2d@ incl, array<shape2d@>@ excl);

				/// constructor
				/*! \param incl object to be included
				    \param excl object to be excluded (subtracted) */
class difference2d:   difference2d(shape2d@ incl, shape2d@ excl);

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class difference2d:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class difference2d:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class difference2d:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class difference2d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class difference2d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class difference2d:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! difference3d is a 3-dimensional boolean operation. It can be invoked either 	
				   explicitly or using subtraction operator:
				   \n\n explicit: solid@ object = difference3d(sphere(100),sphere(50));
				   \n\n using subtraction operator: solid@ object = sphere(100) - sphere(50);
			    */
classdoc difference3d:  

				/// constructor
				/*! \param incl object to be included
				    \param excl array of objects to be excluded (subtracted) */
class difference3d:   difference3d(array<solid@>@ incl, array<solid@>@ excl);

				/// constructor
				/*! \param incl array of objects to be included
				    \param excl object to be excluded (subtracted) */
class difference3d:   difference3d(array<solid@>@ incl, solid@ excl);

				/// constructor
				/*! \param incl object to be included
				    \param excl array of objects to be excluded (subtracted) */
class difference3d:   difference3d(solid@ incl, array<solid@>@ excl);

				/// constructor
				/*! \param incl objects to be included
				    \param excl objects to be excluded (subtracted) */
class difference3d:   difference3d(solid@ incl, solid@ excl);

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class difference3d:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class difference3d:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class difference3d:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class difference3d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class difference3d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class difference3d:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! hull2d is a 2-dimensional boolean operation. It encapsulates
				    the input objects with a convex shape. It can for example be used
					to create a rectangle with rounded cornes using 4 circles.
			    */
classdoc hull2d: 

				/// constructor
				/*! \param arr array of 2d shapes */
class hull2d:     hull2d(array<shape2d@>@ arr);

				/// constructor
				/*! \param s1 shape  
				    \param s2 shape  */
class hull2d:     hull2d(const shape2d@ s1, const shape2d@ s2 );

				/// constructor
				/*! \param s1 shape  
				    \param s3 shape  
				    \param s2 shape  */
class hull2d:     hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3 );

				/// constructor
				/*! \param s1 shape  
				    \param s2 shape  
				    \param s3 shape  
				    \param s4 shape  */
class hull2d:     hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4 );

				/// constructor
				/*! \param s1 shape  
				    \param s2 shape  
				    \param s3 shape  
				    \param s4 shape  
				    \param s5 shape  */
class hull2d:     hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4, const shape2d@ s5 );

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class hull2d:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class hull2d:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class hull2d:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class hull2d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class hull2d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class hull2d:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! minkowski2d is a 2-dimensional boolean operation requiring exactly 
				    2 parameters, a and b. The first parameter (a) is generally the larger 
					and can be concave or convex. The second parameter (b) is assumed smaller 
					and convex (such as a circle). Typical use of the minkowski sum is to 
					create an object with rounded corners.
			    */
classdoc minkowski2d: 

				/// constructor
				/*! \param a convex/concave object to be modified  
				    \param b convex 'tool' object  */
class minkowski2d: minkowski2d(const shape2d@ a, const shape2d@ b )
				 
                /// return bounding box
				/*! \return The bounding box of the minkowski sum*/
class minkowski2d: boundingbox@ box() const

				/// Object type string
				/*! \return type name string*/ 
class minkowski2d: string Type() const


				/*! minkowski3d is a 3-dimensional boolean operation requiring exactly 
				    2 parameters, a and b. The first parameter (a) is generally the larger 
					and can be concave or convex. The second parameter (b) is assumed smaller 
					and convex (such as a circle). Typical use of the minkowski sum is to 
					create an object with rounded edges.
			    */
classdoc minkowski3d: 

				/// constructor
				/*! \param a convex/concave object to be modified  
				    \param b convex 'tool' object  */
class minkowski3d: minkowski3d(const shape2d@ a, const shape2d@ b )
				 
                /// return bounding box
				/*! \return The bounding box of the minkowski sum*/
class minkowski3d: boundingbox@ box() const

				/// Object type string
				/*! \return type name string*/ 
class minkowski3d: string Type() const




				/*! hull3d is a 3-dimensional boolean operation. It encapsulates
				    the input objects with a convex shape. It can for example be used
					to create a cuboid with rounded cornes using 8 spheres.
			    */
classdoc hull3d: 

				/// constructor
				/*! \param arr array of solids  */
class hull3d:    hull3d(array<solid@>@ arr);

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid   */
class hull3d:    hull3d(const solid@ s1, const solid@ s2 );

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid   */
class hull3d:    hull3d(const solid@ s1, const solid@ s2, const solid@ s3 );

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid  
				    \param s4 solid   */
class hull3d:    hull3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4 );

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid  
				    \param s4 solid  
				    \param s5 solid  */
class hull3d:    hull3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4, const solid@ s5 );

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class hull3d:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class hull3d:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class hull3d:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class hull3d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class hull3d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class hull3d:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! intersection2d is a 2-dimensional boolean operation. It can be invoked either 	
				   explicitly or using & operator:
				   \n\n explicit: shape2d@ object = intersection2d(circle(100),translate(75,0,0)*circle(50));
				   \n\n using & operator: shape2d@ object = circle(100) & translate(75,0,0)*circle(50);
			    */
classdoc intersection2d:  

				/// constructor
				/*! \param incl 1st set of objects in intersection
				    \param excl 2nd set of objects in intersection */				   
class intersection2d:    intersection2d(array<shape2d@>@ incl, array<shape2d@>@ excl);

				/// constructor
				/*! \param incl 1st set of objects in intersection
				    \param excl 2nd object in intersection */	
class intersection2d:    intersection2d(array<shape2d@>@ incl, shape2d@ excl);

				/// constructor
				/*! \param incl 1st object in intersection
				    \param excl 2nd set of objects in intersection */	
class intersection2d:    intersection2d(shape2d@ incl, array<shape2d@>@ excl);

				/// constructor
				/*! \param incl 1st object in intersection
				    \param excl 2nd object in intersection */
class intersection2d:    intersection2d(shape2d@ incl, shape2d@ excl);

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class intersection2d:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class intersection2d:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class intersection2d:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class intersection2d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class intersection2d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class intersection2d:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! intersection3d is a 2-dimensional boolean operation. It can be invoked either 	
				   explicitly or using & operator:
				   \n\n explicit: solid@ object = intersection3d(sphere(100),translate(75,0,0)*sphere(50));
				   \n\n using & operator: solid@ object = sphere(100) & translate(75,0,0)*sphere(50);
			    */
classdoc intersection3d: 

				/// constructor
				/*! \param incl 1st set of objects in intersection
				    \param excl 2nd set of objects in intersection */
class intersection3d:   intersection3d(array<solid@>@ incl, array<solid@>@ excl);

				/// constructor
				/*! \param incl 1st set of objects in intersection
				    \param excl 2nd object in intersection */
class intersection3d:   intersection3d(array<solid@>@ incl, solid@ excl);

				/// constructor
				/*! \param incl 1st object in intersection
				    \param excl 2nd set of objects in intersection */
class intersection3d:   intersection3d(solid@ incl, array<solid@>@ excl);

				/// constructor
				/*! \param incl 1st object in intersection
				    \param excl 2nd object in intersection */
class intersection3d:   intersection3d(solid@ incl, solid@ excl);

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class intersection3d:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class intersection3d:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class intersection3d:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class intersection3d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class intersection3d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class intersection3d:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! linear_extrude extrudes a 2d shape in z-direction, creating a solid.
			    */
classdoc linear_extrude: 

				/// constructor
				/*! \param shape 2d profile to be extruded
				    \param height distance in z direction to extrude */
class linear_extrude:    linear_extrude(const shape2d@ shape, double height);

				/// extrusion height
				/*! \return extrusion height */
class linear_extrude:    double height() const;

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class linear_extrude:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class linear_extrude:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class linear_extrude:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class linear_extrude:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class linear_extrude:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class linear_extrude:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! a locsys3d represents local coordinate system directions.
			    */
classdoc locsys3d: 

                /// constructor
				/*! \param xvec local x-direction vector
 				    \param zvec local z-direction vector*/
class locsys3d:   locsys3d(const vec3d@ xvec, const vec3d@ zvec)

				/// class type string
				/*! \return string containing type name */
class locsys3d:   string Type() const;

                /// local x-direction vector
				/*! \return local x-direction vector */
class locsys3d:   vec3d@ x() const;

                /// local y-direction vector
				/*! \return local y-direction vector */
class locsys3d:   vec3d@ y() const;

                /// local z-direction vector
				/*! \return local z-direction vector */
class locsys3d:   vec3d@ z() const;


				/*! mirror is a transformation creating mirror images of 2d or 3d objects.
			    */
classdoc mirror: 


				/// constructor, mirror around origin
				/*! \param dx x-component of mirror plane normal
				    \param dy y-component of mirror plane normal
				    \param dz z-component of mirror plane normal */
class mirror:    mirror(double dx, double dy, double dz);

				/// constructor, mirror around given point
				/*! \param normal mirror plane normal vector
				    \param point point in mirror plane */
class mirror:    mirror(vec3d@ normal, pos3d@ point = pos3d(0,0,0) );

				/// mirror transform normal vector, x-component
				/*! \return normal vector, x-component */
class mirror:    double dx() const;

				/// mirror transform normal vector, y-component
				/*! \return normal vector, y-component */
class mirror:    double dy() const;

				/// mirror transform normal vector, z-component
				/*! \return normal vector,z-component */
class mirror:    double dz() const;

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class mirror:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class mirror:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class mirror:    solid@ opMul(solid@ obj);

class mirror:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class mirror:    tmatrix@ opMul(const tmatrix@ B);

                 /// dump matrix to console
class mirror:    void dump() const;


				/*! hmatrix is a transformation expressed as homogenous transformation matrix.
			    */
classdoc hmatrix: 

				/// constructor, 4 column values
				/*! \param xvec 1st matrix column
				    \param yvec 2nd matrix column
				    \param zvec 3rd matrix column 
				    \param pos  4rd matrix column */
class hmatrix:    hmatrix(const vec3d@ xvec, const vec3d@ yvec, const vec3d@ zvec, const pos3d@ pos = pos3d(0,0,0))

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class hmatrix:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class hmatrix:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class hmatrix:    solid@ opMul(solid@ obj);

class hmatrix:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class hmatrix:    tmatrix@ opMul(const tmatrix@ B);

                 /// dump matrix to console
class hmatrix:    void dump() const;

				/*! offset2d is a special 2d operation used for inflating or shrinking a 2d shape,
				    optionally creating rounded corners and chamfers.
			    */
classdoc offset2d: 

                /// constructor
				/*! \param arr array of 2d profiles to be offset
				    \param r radius if rounded offset required (cannot be combined with delta)
				    \param delta straight offset if shart corners required (cannot be combined with r)
					\param chamfer true if sharp corners to be chamfered (relevant with delta only) */
class offset2d:    offset2d(array<shape2d@>@ arr, double r=0x7fc00000, double delta=0x7fc00000, bool chamfer=false);

                /// constructor
				/*! \param profile 2d profile to be offset
				    \param r radius if rounded offset required (cannot be combined with delta)
				    \param delta straight offset if shart corners required (cannot be combined with r)
					\param chamfer true if sharp corners to be chamfered (relevant with delta only) */
class offset2d:    offset2d(const shape2d@ profile, double r=0x7fc00000, double delta=0x7fc00000, bool chamfer=false);

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class offset2d:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class offset2d:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class offset2d:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class offset2d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class offset2d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class offset2d:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! pface represents a single face of a polyhedron. It contains integer indices
				    referring to the polyhedron vertices. When viewed from outside the polyhedron,
					a pface should list its vertices in CCW sequence.
			    */
classdoc pface: 


                /// polyhedron face constructor
				/*! \param iv1 polyhedron vertex index 
				    \param iv2 polyhedron vertex index  
					\param iv3 polyhedron vertex index  */
class pface:    pface(uint iv1, uint iv2, uint iv3 );

                /// polyhedron face constructor
				/*! \param iv1 polyhedron vertex index 
				    \param iv2 polyhedron vertex index  
					\param iv3 polyhedron vertex index  
					\param iv4 polyhedron vertex index  */
class pface:    pface(uint iv1, uint iv2, uint iv3, uint iv4 );
                
				/// class type string
				/*! \return string containing type name */
class pface:    string Type() const;

				/// number of vertices in face
				/*! \return number of vertices in face */
class pface:    uint nvert() const;

				/// polyhedron vertex index for face index
				/*! \param iv face index
				    \return polyhedron face index */
class pface:    uint vindex(uint iv) const;

				/*! a polygon is a 2d object. It is defined by vertex positions listed in CCW sequence.
			    */
classdoc polygon: 

                /// constructor
				/*! \param points array of 2d positions defining polygon (in CCW order) */
class polygon:    polygon(array<pos2d@>@ points);

                /// constructor (triangle), points must be given in CCW order
				/*! \param p1 position 
				    \param p2 position 
					\param p3 position 	*/
class polygon:    polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3 );

                /// constructor (quadrilateral), points must be given in CCW order
				/*! \param p1 position 
				    \param p2 position 
				    \param p3 position 
					\param p4 position 	*/
class polygon:    polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3, const pos2d@ p4 );

                /// constructor (pentagon), points must be given in CCW order
				/*! \param p1 position 
				    \param p2 position 
				    \param p3 position 
				    \param p4 position 
					\param p5 position 	*/
class polygon:    polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3, const pos2d@ p4, const pos2d@ p5 );

                 /// constructor (spline), points must be given in CCW order
				 /*! \param spline 2d spline curve defining polygon profile
				     \param nseg number of straight segments for spline   */
class polygon:    polygon(const spline2d@ spline, uint nseg=30);

                  /// Polygon area
				  /*! return computed area of polygon */
class polygon:    double area() const;

                  /// Signed polygon area, return negative area for polygons oriented CW
				  /*! return signed computed area of polygon */
class polygon:    double signed_area() const;

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class polygon:    shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class polygon:    shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class polygon:    shape2d@ opSub(shape2d@ b);

				/// class type string
				/*! \return string containing type name */
class polygon:    string Type() const;

				/// number of polygon points
				/*! \return number of polygon points */
class polygon:    uint size() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class polygon:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class polygon:    void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! a polyhedron is a general 3d object, defined by its vertices and polyhedron faces.
				    It is useful in many contexts. It can be constructed directly or by reference to an input file.
			    */
classdoc polyhedron: 

                 /// constructor
				 /*! \param points array of vertex coordinates
				     \param faces array of polyhedron faces */
class polyhedron:    polyhedron(array<pos3d@>@ points, array<pface@>@ faces);

                 /// constructor
				 /*! \param file file name of to import. Must be plain text AMF.
				     \param id index of polyhedron in imported file */
class polyhedron:    polyhedron(string file, uint id=0);

                 /// polyhedron face area
				 /*! \param iface index of polyhedron face
				     \return computed area of polyhedron face */
class polyhedron:    double face_area(uint iface) const;

                 /// polyhedron volume
				 /*! \return computed volume of polyhedron */
class polyhedron:    double volume() const;

                 /// polyhedron face
				 /*! \param iface index of polyhedron face
				     \return polyhedron face */
class polyhedron:    pface@ face(uint iface) const;

                 /// polyhedron vertex
				 /*! \param iv index of polyhedron vertex
				     \return polyhedron vertex position */
class polyhedron:    pos3d@ vertex(uint iv) const;

				/// Boolean union operator+ overload
				/*!  \param b object to union with this object
				     \return resulting solid*/ 
class polyhedron:    solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*!  \param b object to intersect with this object
				     \return resulting solid*/ 
class polyhedron:    solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \param b object to subtract from this object
				     \return resulting solid*/ 
class polyhedron:    solid@ opSub(solid@ b);

				/// class type string
				/*! \return string containing type name */
class polyhedron:    string Type() const;

                 /// Number of faces
				 /*! \return number of faces in polyhedron */
class polyhedron:    uint nface() const;

                 /// Number of vertices
				 /*! \return number of vertices in polyhedron */
class polyhedron:    uint nvert() const;

                 /// Set vertex position
				 /*! \param iv index of polyhedron vertex 
				     \param pos new position of vertex */
class polyhedron:    void set_vertex(uint iv, pos3d@ pos);

                 /// Flip polyhedron face normal
				 /*! \param iface index of polyhedron face */ 
class polyhedron:    void flip_face(uint iface);

                 /// Flip all polyhedron face normals
class polyhedron:    void flip_faces();

                 /// Verify polyhedron against common input mistakes
class polyhedron:    void verify();

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class polyhedron:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class polyhedron:    void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! a pos2d is a position in 2d space.  It is used with 2d objects.
			    */
classdoc pos2d: 


                /// constructor
				/*! \param x coordinate
				    \param y coordinate */
class pos2d:    pos2d(double x,double y); 

                /// distance from other position
				/*! \param pos other position
				    \return distance from pos*/
class pos2d:    double dist(const pos2d@ pos) const;

                /// x coordinate
				/*! \return x coordinate */
class pos2d:    double x() const;

                /// y coordinate
				/*! \return y coordinate */
class pos2d:    double y() const;

				/// class type string
				/*! \return string containing type name */
class pos2d:    string Type() const;


				/*! a pos3d is a position in 3d space.  It is used with 3d objects.
			    */
classdoc pos3d: 


                /// constructor
				/*! \param x coordinate
				    \param y coordinate 
				    \param z coordinate */
class pos3d:    pos3d(double x,double y, double z); 

                /// distance from other position
				/*! \param pos other position
				    \return distance from pos*/
class pos3d:    double dist(const pos3d@ pos) const;

                /// x coordinate
				/*! \return x coordinate */
class pos3d:    double x() const;

                /// y coordinate
				/*! \return y coordinate */
class pos3d:    double y() const;

                /// z coordinate
				/*! \return z coordinate */
class pos3d:    double z() const;

				/// class type string
				/*! \return string containing type name */
class pos3d:    string Type() const;

				/*! a rectangle is a 2d object defined by its extent in x and y. By default it touches the
				    origin and extends along positive x and y.
			    */
classdoc rectangle: 

                /// constructor
				/*! \param dx extent in x direction
				    \param dy extent in y direction
					\param center true if rectangle should be centered on origin */
class rectangle:    rectangle(double dx, double dy, bool center=false);

                 /// extent in x direction
				 /*! \return extent in x direction */
class rectangle:    double dx() const;

                 /// extent in y direction
				 /*! \return extent in y direction */
class rectangle:    double dy() const;

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class rectangle:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class rectangle:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class rectangle:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class rectangle:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class rectangle:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class rectangle:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! rotate_extrude allows extruding a 2d shape along a circular path. A positive
				    angle rotates the object around the y axis (CCW direction).
					
					\n\n solid@ object = rotate_extrude(translate(100,0)*circle(10),deg:60);				    
			    */
classdoc rotate_extrude: 

				/// constructor
				/*! \param shape 2d profile shape to extrude
				    \param deg   rotation in degrees. Rotation is CCW around y axis.
					\param pitch distance to offset profile in y direction for each revolution */
class rotate_extrude:    rotate_extrude(const shape2d@ shape, double deg, double pitch = 0.0);

                /// extrusion angle in degrees
				/*! \return extrusion angle in degrees */
class rotate_extrude:    double deg() const;

                /// extrusion angle in radians
				/*! \return extrusion angle in radians */
class rotate_extrude:    double rad() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class rotate_extrude:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class rotate_extrude:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class rotate_extrude:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class rotate_extrude:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class rotate_extrude:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class rotate_extrude:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! rotate_x is a transformation rotating around the x-axis. Positive angle according to right hand rule.
			    */
classdoc rotate_x: 

                /// constructor (rotate around x)
				/*! \param deg rotation specified in degrees (cannot be combined with rad)
				    \param rad rotation specified in radians (cannot be combined with deg) */
class rotate_x:    rotate_x(double deg=0x7fc00000, double rad=0x7fc00000);

                /// rotation angle in degrees
				/*! \return rotation angle in degrees */
class rotate_x:    double deg() const;

                /// rotation angle in radians
				/*! \return rotation angle in radians */
class rotate_x:    double rad() const;

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class rotate_x:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_x:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_x:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name */
class rotate_x:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class rotate_x:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class rotate_x:    void dump() const;

				/*! rotate_y is a transformation rotating around the y-axis. Positive angle according to right hand rule.
			    */
classdoc rotate_y: 


                /// constructor (rotate around y)
				/*! \param deg rotation specified in degrees (cannot be combined with rad)
				    \param rad rotation specified in radians (cannot be combined with deg) */
class rotate_y:    rotate_y(double deg=0x7fc00000, double rad=0x7fc00000);

                /// rotation angle in degrees
				/*! \return rotation angle in degrees */
class rotate_y:    double deg() const;

                /// rotation angle in radians
				/*! \return rotation angle in radians */
class rotate_y:    double rad() const;


				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class rotate_y:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_y:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_y:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name  */
class rotate_y:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class rotate_y:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class rotate_y:    void dump() const;


				/*! rotate_z is a transformation rotating around the z-axis. Positive angle according to right hand rule.
			    */
classdoc rotate_z: 

                /// constructor (rotate around z)
				/*! \param deg rotation specified in degrees (cannot be combined with rad)
				    \param rad rotation specified in radians (cannot be combined with deg) */
class rotate_z:    rotate_z(double deg=0x7fc00000, double rad=0x7fc00000);

                /// rotation angle in degrees
				/*! \return rotation angle in degrees */
class rotate_z:    double deg() const;

                /// rotation angle in radians
				/*! \return rotation angle in radians */
class rotate_z:    double rad() const;

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class rotate_z:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_z:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class rotate_z:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name */
class rotate_z:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class rotate_z:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class rotate_z:    void dump() const;

				/*! scale is a transformation scaling an object, either uniformly or with different factors in different directions.
			    */
classdoc scale: 

                /// constructor
				/*! \param s scale factor in x,y and z */
class scale:    scale(double s);

                /// constructor
				/*! \param sx scale factor in x
				    \param sy scale factor in y
					\param sz scale factor in z*/
class scale:    scale(double sx, double sy, double sz=1.0);

                 /// scale factor in x direction
				 /*! \return scale factor in x direction */
class scale:    double sx() const;

                 /// scale factor in y direction
				 /*! \return scale factor in y direction */
class scale:    double sy() const;

                 /// scale factor in z direction
				 /*! \return scale factor in z direction */
class scale:    double sz() const;

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class scale:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class scale:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class scale:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name */
class scale:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class scale:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class scale:    void dump() const;

				/*! shape is an abstract base class for all 2d and 3d objects.
			    */
classdoc scale: 


				/// class type string
				/*! \return string containing type name */
class shape:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class shape:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class shape:   void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! shape2d is an abstract base class for all 2d objects.
			    */
classdoc shape2d: 


				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class shape2d:    shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class shape2d:    shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class shape2d:    shape2d@ opSub(shape2d@ b);

				/// class type string
				/*! \return string containing type name */
class shape2d:    string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class shape2d:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class shape2d:    void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! solid is an abstract base class for all 3d objects.
			    */
classdoc solid: 


				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class solid:    solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class solid:    solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class solid:    solid@ opSub(solid@ b);

				/// class type string
				/*! \return string containing type name */
class solid:    string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class solid:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class solid:    void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! a sphere is a 3d object defined by its radius.
			    */
classdoc sphere: 

                /// constructor
				/*! \param r radius */
class sphere:    sphere(double r);

                /// sphere radius
				/*! \return radius */
class sphere:    double r() const;

                /// sphere radius
				/*! \return radius */
class sphere:    double radius() const;

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class sphere:    solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class sphere:    solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class sphere:    solid@ opSub(solid@ b);

				/// class type string
				/*! \return string containing type name */
class sphere:    string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class sphere:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class sphere:    void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! a spline_path defines a cubic spline sweep path.
			    */
classdoc spline_path: 

                /// constructor
				/*! \param p array of points on the spline sweep curve
				    \param v array of "up" vectors orienting the sweep profile, 'v' must have same length as 'p'. */
class spline_path:  spline_path(array<pos3d@>@ p, array<vec3d@>@ v);

                /// constructor
				/*! \param p array of points on the spline sweep curve
				    \param v single "up" vector orienting the sweep profile for all points */
class spline_path:  spline_path(array<pos3d@>@ p, vec3d@ v);

				/// class type string
				/*! \return string containing type name */
class spline_path:  string Type() const


				/*! a sweep creates a solid by sweeping a 2d profile along a path curve
			    */
classdoc sweep: 

                /// constructor
				/*! \param shape 2d profile shape to sweep
				    \param path  The path cirve to sweep along */
class sweep:    sweep(const shape2d@ shape,const spline_path@ path)

                /// return bounding box
				/*! \return The bounding box of the sweep*/
class sweep:    boundingbox@ box() const

				/// class type string
				/*! \return string containing type name */
class sweep:    string Type() const


				/*! a spline2d is a 2d cubic spline curve.
			    */
classdoc spline2d: 


                /// constructor
				/*! \param points array of points on the spline curve*/
class spline2d:   spline2d(array<pos2d@>@ points);

                /// interpolated spline curve position
				/*! \param t normalised curve parameter [0,1]
				    \return curve position corresponding to t */
class spline2d:   pos2d@ pos(double t) const;

				/// class type string
				/*! \return string containing type name */
class spline2d:   string Type() const;

				/*! a spline3d is a 3d cubic spline curve.
			    */
classdoc spline3d: 

                /// constructor
				/*! \param points array of points on the spline curve*/
class spline3d:   spline3d(array<pos3d@>@ points);

                /// interpolated spline curve position
				/*! \param t normalised curve parameter [0,1]
				    \return curve position corresponding to t */
class spline3d:   pos3d@ pos(double t) const;

				/// class type string
				/*! \return string containing type name */
class spline3d:   string Type() const;

                /// interpolated spline tangent curve direction
				/*! \param t normalised curve parameter [0,1]
				    \return curve tangent direction corresponding to t */
class spline3d:   vec3d@ dir(double t) const;


				/*! a square is a 2d quadrilateral with equal dimensions in x and y. 
				    By default it touches the origin and extend along positive x and y.
			    */
classdoc square: 

                /// constructor
				/*! \param size extent in x and y
				    \param center true if square to be centered on origon */
class square:    square(double size, bool center=false);

                /// size of square
				/*! \return size of square */
class square:    double size() const;

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class square:    shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class square:    shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class square:    shape2d@ opSub(shape2d@ b);

				/// class type string
				/*! \return string containing type name */
class square:    string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class square:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class square:    void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! a tmatrix an abstract base class for all transformations.
			    */
classdoc tmatrix: 


				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class tmatrix:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class tmatrix:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class tmatrix:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name */
class tmatrix:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class tmatrix:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class tmatrix:    void dump() const;


				/*! transform_extrude is a special extrision operation, defined by two 2d shapes,
				    representing bottom and top of extrusion.
			    */
classdoc transform_extrude: 


class transform_extrude:    transform_extrude(const shape2d@ bottom, const shape2d@ top);

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class transform_extrude:    solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class transform_extrude:    solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class transform_extrude:    solid@ opSub(solid@ b);

				/// class type string
				/*! \return string containing type name */
class transform_extrude:    string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class transform_extrude:    void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class transform_extrude:    void write_xcsg(string path, double secant_tolerance = - 1.0);


				/*! translate is a transformation translating a 2d or 3d object.
			    */
classdoc translate: 

                /// constructor
				/*! \param dx translation in x direction
				    \param dy translation in y direction
				    \param dz translation in z direction */
class translate:    translate(double dx, double dy, double dz=0.0);

                /// translation in x direction
				/*! \return translation in x direction */
class translate:    double dx() const;

                /// translation in y direction
				/*! \return translation in y direction */
class translate:    double dy() const;

                /// translation in z direction
				/*! \return translation in z direction */
class translate:    double dz() const;

				/// transform a point: pos3d@ p = T*obj;
				/*! \param obj position to be transformed
				    \return transformed position */
class translate:    pos3d@ opMul(pos3d@ obj);

				/// transform a 2d shape: shape2d@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class translate:    shape2d@ opMul(shape2d@ obj);

				/// transform a solid: solid@ s = T*obj;
				/*! \param obj object to be transformed
				    \return transformed object */
class translate:    solid@ opMul(solid@ obj);

				/// class type string
				/*! \return string containing type name */
class translate:    string Type() const;

                /// matrix multiplication: A = T*B
				/*! \param B matrix to be post-multiplied with this matrix
				    \return resulting matrixt */
class translate:    tmatrix@ opMul(const tmatrix@ B);

                /// dump matrix to console
class translate:    void dump() const;

				/*! union2d is a 2-dimensional boolean operation. It can be invoked either 	
				   explicitly or using + operator:
				   \n\n explicit: shape2d@ object = union2d(circle(100),translate(75,0,0)*circle(50));
				   \n\n using & operator: shape2d@ object = circle(100) + translate(75,0,0)*circle(50);
			    */
classdoc union2d: 


				/// constructor
				/*! \param arr array of 2d shapes  */
class union2d:    union2d(array<shape2d@>@ arr);

				/// constructor
				/*! \param s1 2d shape  
				    \param s2 2d shape   */
class union2d:    union2d(const shape2d@ s1, const shape2d@ s2 );

				/// constructor
				/*! \param s1 2d shape  
				    \param s2 2d shape  
				    \param s3 2d shape   */
class union2d:    union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3 );

				/// constructor
				/*! \param s1 2d shape  
				    \param s2 2d shape  
				    \param s3 2d shape  
				    \param s4 2d shape   */
class union2d:    union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4 );

				/// constructor
				/*! \param s1 2d shape  
				    \param s2 2d shape  
				    \param s3 2d shape  
				    \param s4 2d shape  
				    \param s5 2d shape  */
class union2d:    union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4, const shape2d@ s5 );

				/// Boolean union operator+ overload
				/*! \return resulting 2d shape*/ 
class union2d:   shape2d@ opAdd(shape2d@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting 2d shape*/ 
class union2d:   shape2d@ opAnd(shape2d@ b);

				/// Boolean difference operator- overload
				/*! \return resulting 2d shape*/ 
class union2d:   shape2d@ opSub(shape2d@ b);

				/// Object type string
				/*! \return type name string*/ 
class union2d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class union2d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class union2d:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! fill2d is a 2-dimensional boolean operation that removes internal holes
				    in in 2d shapes, but leaves a possibly concave outer contour intact.
				    fill2d can be invoked either on a single shape2d or an array. 
			    */
classdoc fill2d: 

				/// constructor
				/*! \param arr array of 2d shapes  */
class fill2d:    fill2d(array<shape2d@>@ arr);

				/// constructor
				/*! \param s1 2d shape  */
class fill2d:    fill2d(const shape2d@ s1 );

				/// Object type string
				/*! \return type name string*/ 
class fill2d:   string Type() const;

				/// union3d constructor
				/*! \param arr array of solids  */
class union3d:    union3d(array<solid@>@ arr);

				/*! union3d is a 3-dimensional boolean operation. It can be invoked either 	
				   explicitly or using + operator:
				   \n\n explicit: solid@ object = union3d(sphere(100),translate(75,0,0)*sphere(50));
				   \n\n using & operator: solid@ object = sphere(100) + translate(75,0,0)*sphere(50);
			    */
classdoc union3d: 


				/// constructor
				/*! \param s1 solid  
				    \param s2 solid   */
class union3d:    union3d(const solid@ s1, const solid@ s2 );


				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid   */
class union3d:    union3d(const solid@ s1, const solid@ s2, const solid@ s3 );

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid  
				    \param s4 solid   */
class union3d:    union3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4 );

				/// constructor
				/*! \param s1 solid  
				    \param s2 solid  
				    \param s3 solid  
				    \param s4 solid  
				    \param s5 solid  */
class union3d:    union3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4, const solid@ s5 );

				/// Boolean union operator+ overload
				/*! \return resulting solid*/ 
class union3d:   solid@ opAdd(solid@ b);

				/// Boolean intersection operator& overload
				/*! \return resulting solid*/ 
class union3d:   solid@ opAnd(solid@ b);

				/// Boolean difference operator- overload
				/*! \return resulting solid*/ 
class union3d:   solid@ opSub(solid@ b);

				/// Object type string
				/*! \return type name string*/ 
class union3d:   string Type() const;

				/// Write to OpenSCAD .csg file
				/*! \param path file path*/ 
class union3d:   void write_csg(string path);

				/// Write to AngelCAD .xcsg file
				/*! \param path file path
				   \param secant_tolerance tolerance for geometry precision */ 
class union3d:   void write_xcsg(string path, double secant_tolerance = - 1.0);

				/*! vec2d is a 2-dimensional vector offering useful operations such as dot and cross products.
			    */
classdoc vec2d: 

                /// constructor
				/*! \param p1 vector start position
				    \param p2 vector end position*/
class vec2d:   vec2d(const pos2d@ p1, const pos2d@ p2);

                /// constructor
				/*! \param x vector x component
				    \param y vector y component*/
class vec2d:   vec2d(double x,double y);

               /// length of vector
			   /*! \return length of vector */
class vec2d:   double length() const;

               /// vector x component
			   /*! \return vector x component */
class vec2d:   double x() const;

               /// vector y component
			   /*! \return vector y component */
class vec2d:   double y() const;

				/// class type string
				/*! \return string containing type name */
class vec2d:   string Type() const;

               /// cross product: double cp = v.cross(other);
			   /*! \param other vector to multiply with
			       \return cross product value */
class vec2d:   double cross(const vec2d@ other) const;

               /// dot product: double cp = v.dot(other);
			   /*! \param other vector to multiply with
			       \return dot product value */
class vec2d:   double dot(const vec2d@ other) const;

               /// angle between: double rad = v.angle(other);
			   /*! \param other vector to compute angle relative to this
			       \return angle value in radians*/
class vec2d:   double angle(const vec2d@ other) const;

               /// normalise vector length
class vec2d:   void normalise();

				/*! vec3d is a 3-dimensional vector offering useful operations such as dot and cross products.
			    */
classdoc vec3d: 

                /// constructor
				/*! \param x vector x component
				    \param y vector y component
				    \param z vector z component */
class vec3d:   vec3d(double x,double y, double z);

               /// length of vector
			   /*! \return length of vector */
class vec3d:   double length() const;

               /// vector x component
			   /*! \return vector x component */
class vec3d:   double x() const;

               /// vector y component
			   /*! \return vector y component */
class vec3d:   double y() const;

               /// vector z component
			   /*! \return vector z component */
class vec3d:   double z() const;

				/// class type string
				/*! \return string containing type name */
class vec3d:   string Type() const;

               /// cross product: double cp = v.cross(other);
			   /*! \param other vector to multiply with
			       \return cross product value */
class vec3d:   vec3d@ cross(const vec3d@ other) const;

               /// dot product: double cp = v.dot(other);
			   /*! \param other vector to multiply with
			       \return dot product value */
class vec3d:   double dot(const vec3d@ other) const;

               /// angle between: double rad = v.angle(other);
			   /*! \param other vector to compute angle relative to this
			       \return angle value in radians*/
class vec3d:   double angle(const vec3d@ other) const;

               /// normalise vector length
class vec3d:   void normalise();

