#ifndef ANGELCAD_AUTODOC
#define ANGELCAD_AUTODOC
/*
This is AngelCAD autogenerated AngelScript documentation
AngelCAD version: v1.2-00
For language description, see: 
 * The script language   : http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script.html
 * Script class overview : http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_class_desc.html 

Below follows a list of AngelCAD classes in alphabetical order written quasi c++ style
to facilitate using it as direct input to doxygen documentation system.
*/

class OStream
{ 
public: 
   OStream& flush();
   OStream& opShl(bool fValue);
   OStream& opShl(const string&in szString);
   OStream& opShl(double flValue);
   OStream& opShl(float flValue);
   OStream& opShl(int64 iValue);
   OStream& opShl(uint64 uiValue);
   OStream& seekp(int64 iOffset, seekdir way);
   OStream& seekp(int64 iPos);
   bool bad() const;
   bool eof() const;
   bool fail() const;
   bool good() const;
   bool opImplConv() const;
   int64 tellp() const;
   void clear();
}; 

class array
{ 
public: 
   T[]@ array(int&in);
   T[]@ array(int&in, uint length);
   T[]@ array(int&in, uint length, const T&in value);

   T& opIndex(uint index);
   T[]& opAssign(const T[]&in);
   bool empty() const;
   bool isEmpty() const;
   bool opEquals(const T[]&in) const;
   const T& opIndex(uint index) const;
   int find(const T&in value) const;
   int find(uint startAt, const T&in value) const;
   int findByRef(const T&in value) const;
   int findByRef(uint startAt, const T&in value) const;
   uint get_length() const;
   uint length() const;
   uint size() const;
   void erase(uint);
   void insert(uint, const T&in);
   void insertAt(uint index, const T&in value);
   void insertLast(const T&in value);
   void pop_back();
   void push_back(const T&in);
   void removeAt(uint index);
   void removeLast();
   void reserve(uint length);
   void resize(uint length);
   void reverse();
   void set_length(uint);
   void sortAsc();
   void sortAsc(uint startAt, uint count);
   void sortDesc();
   void sortDesc(uint startAt, uint count);
}; 

/// bounding box aligned with system axes
/*! A bounding box representes the range of an object in x,y and z */
class boundingbox
{ 
public: 
   /// constructor
   /*! creates an empty/uninitialised bounding box */
   boundingbox();

   bool is_empty() const;
   /// bounding box extent
   /*! \return bounding box extent in x-direction*/
   double dx() const;
   /// bounding box extent
   /*! \return bounding box extent in y-direction*/
   double dy() const;
   /// bounding box extent
   /*! \return bounding box extent in z-direction*/
   double dz() const;
   /// center position
   /*! \return bounding box geometric center*/
   pos3d@ center() const;
   /// low position
   /*! \return position containing minimum x,y,z*/
   pos3d@ p1() const;
   /// high position
   /*! \return position containing maximum x,y,z*/
   pos3d@ p2() const;
   string Type() const;
   /// enclose a new position, this may extend the boundingbox
   /*! \param p position to enclose*/
   void enclose(pos3d@ p);
}; 

/// circle, centered at origin
/*! A 2d object defined by its radius. Centered on origin. */
class circle : public shape2d
{ 
public: 
   circle(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3 );
   /// constructor
   /*! \param r radius of circle */
   circle(double r);

   boundingbox@ box() const;
   /// radius of circle
   /*! \return radius of circle */
   double r() const;
   /// radius of circle
   /*! \return radius of circle */
   double radius() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// cone with axis in z-direction, by default extending from origin
/*! A cone extends in the z-direction.
By default the bottom is at origin */
class cone : public solid
{ 
public: 
   /// constructor
   /*! \param h height of cone
   \param r1 bottom radius of cone
   \param r2 top radius of cone
   \param center true if cone is centered in z-direction */
   cone(double h, double r1, double r2, bool center=false);

   boundingbox@ box() const;
   /// height of cone
   /*! \return height of cone */
   double h() const;
   /// height of cone
   /*! \return height of cone */
   double height() const;
   /// bottom radius
   /*! \return bottom radius */
   double r1() const;
   /// top radius
   /*! \return top radius */
   double r2() const;
   /// bottom radius
   /*! \return bottom radius */
   double radius1() const;
   /// top radius
   /*! \return top radius */
   double radius2() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// cube, by default in 1st octant with one corner toucing origin
class cube : public solid
{ 
public: 
   /// constructor
   /*! \param size length of sides
   \param center true if cube is centered on origin*/
   cube(double size, bool center=false);

   boundingbox@ box() const;
   /// size of cube
   /*! \return side length*/
   double size() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// cuboid, by default in 1st octant with one corner toucing origin
/*! A cuboid is like a cube, but with separate dimensions in x,y and z.
By default the cuboid touches the origin, and extends along positive x,y,z. */
class cuboid : public solid
{ 
public: 
   /// constructor
   /*! \param dx length in x-drection
   \param dy length of y-direction
   \param dz length of z-direction
   \param center true if cuboid is centered on origin */
   cuboid(double dx, double dy, double dz, bool center=false);

   boundingbox@ box() const;
   /// length in x-drection
   /*! \return length in x-drection */
   double dx() const;
   /// length in y-drection
   /*! \return length in x-drection */
   double dy() const;
   /// length in z-drection
   /*! \return length in x-drection */
   double dz() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// cylinder with axis in z-direction, by default extending from origin
/*! A cylinder is defined by height and radius.
By default the cuboid extends from the origin, in z-direction. */
class cylinder : public solid
{ 
public: 
   /// constructor
   /*! \param h height of cylinder
   \param r radius of cylinder
   \param center true if cylinder is centered on origin in z-direction */
   cylinder(double h, double r, bool center=false);

   boundingbox@ box() const;
   /// Height of cylnder
   /*! \return height of cylnder */
   double h() const;
   /// Height of cylnder
   /*! \return height of cylnder */
   double height() const;
   /// Radius of cylnder
   /*! \return radius of cylnder */
   double r() const;
   /// Radius of cylnder
   /*! \return radius of cylnder */
   double radius() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

class dictionary
{ 
public: 
   dictionary@ dictionary();

   bool delete(const string&in);
   bool empty() const;
   bool exists(const string&in) const;
   bool get(const string&in, ?&out) const;
   bool get(const string&in, double&out) const;
   bool get(const string&in, int64&out) const;
   bool isEmpty() const;
   const dictionaryValue& opIndex(const string&in) const;
   dictionary& opAssign(const dictionary&in);
   dictionaryValue& opIndex(const string&in);
   string[]@ getKeys() const;
   uint getSize() const;
   uint size() const;
   void clear();
   void deleteAll();
   void erase(const string&in);
   void set(const string&in, const ?&in);
   void set(const string&in, const double&in);
   void set(const string&in, const int64&in);
}; 

/// 2d difference boolean operation
/*! difference2d is a 2-dimensional boolean operation. It can be invoked either
explicitly or using subtraction operator:
\n\n explicit: shape2d@ object = difference2d(circle(100),circle(50));
\n\n using subtraction operator: shape2d@ object = circle(100) - circle(50);
*/
class difference2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param incl object to be included
   \param excl object to be excluded (subtracted) */
   difference2d(shape2d@ incl, shape2d@ excl);

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d difference boolean operation
/*! difference3d is a 3-dimensional boolean operation. It can be invoked either
explicitly or using subtraction operator:
\n\n explicit: solid@ object = difference3d(sphere(100),sphere(50));
\n\n using subtraction operator: solid@ object = sphere(100) - sphere(50);
*/
class difference3d : public solid
{ 
public: 
   /// constructor
   /*! \param incl objects to be included
   \param excl objects to be excluded (subtracted) */
   difference3d(solid@ incl, solid@ excl);

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 2d fill operation, filling holes in input shapes
/*! fill2d is a 2-dimensional boolean operation that removes internal holes
in in 2d shapes, but leaves a possibly concave outer contour intact.
fill2d can be invoked either on a single shape2d or an array.
*/
class fill2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param arr array of 2d shapes  */
   fill2d(array<shape2d@>@ arr);
   fill2d(const shape2d@ s1);

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Homogeneous transformation matrix
/*! hmatrix is a transformation expressed as homogenous transformation matrix.
*/
class hmatrix : public tmatrix
{ 
public: 
   hmatrix(const vec3d@ xvec, const vec3d@ yvec, const pos3d@ pos = pos3d(0,0,0));
   /// constructor, 4 column values
   /*! \param xvec 1st matrix column
   \param yvec 2nd matrix column
   \param zvec 3rd matrix column
   \param pos  4rd matrix column */
   hmatrix(const vec3d@ xvec, const vec3d@ yvec, const vec3d@ zvec, const pos3d@ pos = pos3d(0,0,0));

   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// 2d hull operation, enclosing the input shapes
/*! hull2d is a 2-dimensional boolean operation. It encapsulates
the input objects with a convex shape. It can for example be used
to create a rectangle with rounded cornes using 4 circles.
*/
class hull2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param arr array of 2d shapes */
   hull2d(array<shape2d@>@ arr);
   /// constructor
   /*! \param s1 shape
   \param s2 shape  */
   hull2d(const shape2d@ s1, const shape2d@ s2 );
   /// constructor
   /*! \param s1 shape
   \param s3 shape
   \param s2 shape  */
   hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3 );
   /// constructor
   /*! \param s1 shape
   \param s2 shape
   \param s3 shape
   \param s4 shape  */
   hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4 );
   /// constructor
   /*! \param s1 shape
   \param s2 shape
   \param s3 shape
   \param s4 shape
   \param s5 shape  */
   hull2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4, const shape2d@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d hull operation, enclosing the input solids
/*! hull3d is a 3-dimensional boolean operation. It encapsulates
the input objects with a convex shape. It can for example be used
to create a cuboid with rounded cornes using 8 spheres.
*/
class hull3d : public solid
{ 
public: 
   /// constructor
   /*! \param arr array of solids  */
   hull3d(array<solid@>@ arr);
   /// constructor
   /*! \param s1 solid
   \param s2 solid   */
   hull3d(const solid@ s1, const solid@ s2 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid   */
   hull3d(const solid@ s1, const solid@ s2, const solid@ s3 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid
   \param s4 solid   */
   hull3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid
   \param s4 solid
   \param s5 solid  */
   hull3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4, const solid@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 2d intersection boolean operation
/*! intersection2d is a 2-dimensional boolean operation. It can be invoked either
explicitly or using & operator:
\n\n explicit: shape2d@ object = intersection2d(circle(100),translate(75,0,0)*circle(50));
\n\n using & operator: shape2d@ object = circle(100) & translate(75,0,0)*circle(50);
*/
class intersection2d : public shape2d
{ 
public: 
   intersection2d(array<shape2d@>@ arr);
   intersection2d(const shape2d@ s1, const shape2d@ s2 );
   intersection2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3 );
   intersection2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4 );
   intersection2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4, const shape2d@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d intersection boolean operation
/*! intersection3d is a 2-dimensional boolean operation. It can be invoked either
explicitly or using & operator:
\n\n explicit: solid@ object = intersection3d(sphere(100),translate(75,0,0)*sphere(50));
\n\n using & operator: solid@ object = sphere(100) & translate(75,0,0)*sphere(50);
*/
class intersection3d : public solid
{ 
public: 
   intersection3d(array<solid@>@ arr);
   intersection3d(const solid@ s1, const solid@ s2 );
   intersection3d(const solid@ s1, const solid@ s2, const solid@ s3 );
   intersection3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4 );
   intersection3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4, const solid@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Extrude 2d shape in z direction into 3d solid
/*! linear_extrude extrudes a 2d shape in z-direction, creating a solid.
*/
class linear_extrude : public solid
{ 
public: 
   /// constructor
   /*! \param shape 2d profile to be extruded
   \param height distance in z direction to extrude */
   linear_extrude(const shape2d@ shape, double height);

   boundingbox@ box() const;
   /// extrusion height
   /*! \return extrusion height */
   double height() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d localsystem
/*! a locsys3d represents local coordinate system directions.
*/
class locsys3d
{ 
public: 
   /// constructor
   /*! \param xvec local x-direction vector
   \param zvec local z-direction vector*/
   locsys3d(const vec3d@ xvec, const vec3d@ zvec);

   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// local x-direction vector
   /*! \return local x-direction vector */
   vec3d@ x() const;
   /// local y-direction vector
   /*! \return local y-direction vector */
   vec3d@ y() const;
   /// local z-direction vector
   /*! \return local z-direction vector */
   vec3d@ z() const;
}; 

class map
{ 
public: 
   map<T_key,T_value>@ map(int&in);
   map<T_key,T_value>@ map(int&in, map<T_key,T_value>@);

   T_value& find(const T_key&in);
   T_value& find(const T_key&in, bool&out);
   bool contains(const T_key&in);
   bool empty();
   bool erase(const map_iterator<T_key,T_value>&in);
   const T_value& get_opIndex(const T_key&in) const;
   int erase(const map_iterator<T_key,T_value>&in, const map_iterator<T_key,T_value>&in);
   int size();
   map<T_key,T_value>& opAssign(map<T_key,T_value>@);
   map<T_key,T_value>& swap(map<T_key,T_value>&inout);
   map_iterator<T_key,T_value> begin();
   map_iterator<T_key,T_value> end();
   map_iterator<T_key,T_value> find_iterator(const T_key&in);
   void SetDirectcomp(bool);
   void clear();
   void erase(const T_key&in);
   void insert(const T_key&in, const T_value&in);
   void set_opIndex(const T_key&in, const T_value&in);
}; 

class map_iterator
{ 
public: 
   T_value& current_value();
   T_value& get_value();
   bool IsEnd();
   bool IsValid();
   bool next();
   bool opEquals(const map_iterator<T_key,T_value>&in);
   bool opPostInc();
   bool opPreInc();
   const T_key& current_key();
   const T_key& get_key();
   map_iterator<T_key,T_value>& opAssign(const map_iterator<T_key,T_value>&in);
   void set_value(const T_value&in);
}; 

/// 2d Minkowski sum operation
/*! minkowski2d is a 2-dimensional boolean operation requiring exactly
2 parameters, a and b. The first parameter (a) is generally the larger
and can be concave or convex. The second parameter (b) is assumed smaller
and convex (such as a circle). Typical use of the minkowski sum is to
create an object with rounded corners.
*/
class minkowski2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param a convex/concave object to be modified
   \param b convex 'tool' object  */
   minkowski2d(const shape2d@ a, const shape2d@ b );

   /// return bounding box
   /*! \return The bounding box of the minkowski sum*/
   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d Minkowski sum operation
/*! minkowski3d is a 3-dimensional boolean operation requiring exactly
2 parameters, a and b. The first parameter (a) is generally the larger
and can be concave or convex. The second parameter (b) is assumed smaller
and convex (such as a circle). Typical use of the minkowski sum is to
create an object with rounded edges.
*/
class minkowski3d : public solid
{ 
public: 
   minkowski3d(const solid@ a, const solid@ b );

   /// return bounding box
   /*! \return The bounding box of the minkowski sum*/
   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Mirror transformation around given point
/*! mirror is a transformation creating mirror images of 2d or 3d objects.
*/
class mirror : public tmatrix
{ 
public: 
   /// constructor, mirror around origin
   /*! \param dx x-component of mirror plane normal
   \param dy y-component of mirror plane normal
   \param dz z-component of mirror plane normal */
   mirror(double dx, double dy, double dz);
   /// constructor, mirror around given point
   /*! \param normal mirror plane normal vector
   \param point point in mirror plane */
   mirror(vec3d@ normal, pos3d@ point = pos3d(0,0,0) );

   /// mirror transform normal vector, x-component
   /*! \return normal vector, x-component */
   double dx() const;
   /// mirror transform normal vector, y-component
   /*! \return normal vector, y-component */
   double dy() const;
   /// mirror transform normal vector, z-component
   /*! \return normal vector,z-component */
   double dz() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// 2d profile offset
/*! offset2d is a special 2d operation used for inflating or shrinking a 2d shape,
optionally creating rounded corners and chamfers.
*/
class offset2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param arr array of 2d profiles to be offset
   \param r radius if rounded offset required (cannot be combined with delta)
   \param delta straight offset if shart corners required (cannot be combined with r)
   \param chamfer true if sharp corners to be chamfered (relevant with delta only) */
   offset2d(array<shape2d@>@ arr, double r=0x7fc00000, double delta=0x7fc00000, bool chamfer=false);
   /// constructor
   /*! \param profile 2d profile to be offset
   \param r radius if rounded offset required (cannot be combined with delta)
   \param delta straight offset if shart corners required (cannot be combined with r)
   \param chamfer true if sharp corners to be chamfered (relevant with delta only) */
   offset2d(const shape2d@ profile, double r=0x7fc00000, double delta=0x7fc00000, bool chamfer=false);

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Polyhedron face
/*! pface represents a single face of a polyhedron. It contains integer indices
referring to the polyhedron vertices. When viewed from outside the polyhedron,
a pface should list its vertices in CCW sequence.
*/
class pface
{ 
public: 
   /// polyhedron face constructor
   /*! \param iv1 polyhedron vertex index
   \param iv2 polyhedron vertex index
   \param iv3 polyhedron vertex index  */
   pface(uint iv1, uint iv2, uint iv3 );
   /// polyhedron face constructor
   /*! \param iv1 polyhedron vertex index
   \param iv2 polyhedron vertex index
   \param iv3 polyhedron vertex index
   \param iv4 polyhedron vertex index  */
   pface(uint iv1, uint iv2, uint iv3, uint iv4 );

   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// number of vertices in face
   /*! \return number of vertices in face */
   uint nvert() const;
   /// polyhedron vertex index for face index
   /*! \param iv face index
   \return polyhedron face index */
   uint vindex(uint iv) const;
}; 

/// polygon, vertices in CCW order
/*! a polygon is a 2d object. It is defined by vertex positions listed in CCW sequence.
*/
class polygon : public shape2d
{ 
public: 
   polygon(array<pos2d@>@ points, bool check=true);
   /// constructor (triangle), points must be given in CCW order
   /*! \param p1 position
   \param p2 position
   \param p3 position 	*/
   polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3 );
   /// constructor (quadrilateral), points must be given in CCW order
   /*! \param p1 position
   \param p2 position
   \param p3 position
   \param p4 position 	*/
   polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3, const pos2d@ p4 );
   /// constructor (pentagon), points must be given in CCW order
   /*! \param p1 position
   \param p2 position
   \param p3 position
   \param p4 position
   \param p5 position 	*/
   polygon(const pos2d@ p1, const pos2d@ p2, const pos2d@ p3, const pos2d@ p4, const pos2d@ p5 );
   /// constructor (spline), points must be given in CCW order
   /*! \param spline 2d spline curve defining polygon profile
   \param nseg number of straight segments for spline   */
   polygon(const spline2d@ spline, uint nseg=30);
   polygon(double r, uint np);

   boundingbox@ box() const;
   /// Polygon area
   /*! return computed area of polygon */
   double area() const;
   /// Signed polygon area, return negative area for polygons oriented CW
   /*! return signed computed area of polygon */
   double signed_area() const;
   pos2d@ vertex(uint iv) const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
   /// number of polygon points
   /*! \return number of polygon points */
   uint size() const;
}; 

/// Closed polyhedron volume defined by vertices and planar faces
/*! a polyhedron is a general 3d object, defined by its vertices and polyhedron faces.
It is useful in many contexts. It can be constructed directly or by reference to an input file.
*/
class polyhedron : public solid
{ 
public: 
   polyhedron(array<pos3d@>@ points);
   /// constructor
   /*! \param points array of vertex coordinates
   \param faces array of polyhedron faces */
   polyhedron(array<pos3d@>@ points, array<pface@>@ faces);
   polyhedron(string file, int id=-1);

   boundingbox@ box() const;
   /// polyhedron face area
   /*! \param iface index of polyhedron face
   \return computed area of polyhedron face */
   double face_area(uint iface) const;
   /// polyhedron volume
   /*! \return computed volume of polyhedron */
   double volume() const;
   /// polyhedron face
   /*! \param iface index of polyhedron face
   \return polyhedron face */
   pface@ face(uint iface) const;
   /// polyhedron vertex
   /*! \param iv index of polyhedron vertex
   \return polyhedron vertex position */
   pos3d@ vertex(uint iv) const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
   /// Number of faces
   /*! \return number of faces in polyhedron */
   uint nface() const;
   /// Number of vertices
   /*! \return number of vertices in polyhedron */
   uint nvert() const;
   /// Flip polyhedron face normal
   /*! \param iface index of polyhedron face */
   void flip_face(uint iface);
   /// Flip all polyhedron face normals
   void flip_faces();
   /// Set vertex position
   /*! \param iv index of polyhedron vertex
   \param pos new position of vertex */
   void set_vertex(uint iv, pos3d@ pos);
   void verify() const;
}; 

/// 2d position coordinates
/*! a pos2d is a position in 2d space.  It is used with 2d objects.
*/
class pos2d
{ 
public: 
   /// constructor
   /*! \param x coordinate
   \param y coordinate */
   pos2d(double x,double y);

   /// distance from other position
   /*! \param pos other position
   \return distance from pos*/
   double dist(const pos2d@ pos) const;
   /// x coordinate
   /*! \return x coordinate */
   double x() const;
   /// y coordinate
   /*! \return y coordinate */
   double y() const;
   pos2d@ opMul(double f1);
   pos2d@ opMul_r(double f1);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
}; 

/// 3d position coordinates
/*! a pos3d is a position in 3d space.  It is used with 3d objects.
*/
class pos3d
{ 
public: 
   /// constructor
   /*! \param x coordinate
   \param y coordinate
   \param z coordinate */
   pos3d(double x,double y, double z);

   /// distance from other position
   /*! \param pos other position
   \return distance from pos*/
   double dist(const pos3d@ pos) const;
   /// x coordinate
   /*! \return x coordinate */
   double x() const;
   /// y coordinate
   /*! \return y coordinate */
   double y() const;
   /// z coordinate
   /*! \return z coordinate */
   double z() const;
   pos3d@ opMul(double f1);
   pos3d@ opMul_r(double f1);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
}; 

/// rectangle, by default located in 1st quadrant touching origin
/*! a rectangle is a 2d object defined by its extent in x and y. By default it touches the
origin and extends along positive x and y.
*/
class rectangle : public shape2d
{ 
public: 
   /// constructor
   /*! \param dx extent in x direction
   \param dy extent in y direction
   \param center true if rectangle should be centered on origin */
   rectangle(double dx, double dy, bool center=false);

   boundingbox@ box() const;
   /// extent in x direction
   /*! \return extent in x direction */
   double dx() const;
   /// extent in y direction
   /*! \return extent in y direction */
   double dy() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Extrude 2d shape CCW in XZ plane into 3d solid
/*! rotate_extrude allows extruding a 2d shape along a circular path. A positive
angle rotates the object around the y axis (CCW direction).
\n\n solid@ object = rotate_extrude(translate(100,0)*circle(10),deg:60);
*/
class rotate_extrude : public solid
{ 
public: 
   /// constructor
   /*! \param shape 2d profile shape to extrude
   \param deg   rotation in degrees. Rotation is CCW around y axis.
   \param pitch distance to offset profile in y direction for each revolution */
   rotate_extrude(const shape2d@ shape, double deg, double pitch = 0.0);

   boundingbox@ box() const;
   /// extrusion angle in degrees
   /*! \return extrusion angle in degrees */
   double deg() const;
   /// extrusion angle in radians
   /*! \return extrusion angle in radians */
   double rad() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Rotation around x
/*! rotate_x is a transformation rotating around the x-axis. Positive angle according to right hand rule.
*/
class rotate_x : public tmatrix
{ 
public: 
   /// constructor (rotate around x)
   /*! \param deg rotation specified in degrees (cannot be combined with rad)
   \param rad rotation specified in radians (cannot be combined with deg) */
   rotate_x(double deg=0x7fc00000, double rad=0x7fc00000);

   /// rotation angle in degrees
   /*! \return rotation angle in degrees */
   double deg() const;
   /// rotation angle in radians
   /*! \return rotation angle in radians */
   double rad() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// Rotation around y
/*! rotate_y is a transformation rotating around the y-axis. Positive angle according to right hand rule.
*/
class rotate_y : public tmatrix
{ 
public: 
   /// constructor (rotate around y)
   /*! \param deg rotation specified in degrees (cannot be combined with rad)
   \param rad rotation specified in radians (cannot be combined with deg) */
   rotate_y(double deg=0x7fc00000, double rad=0x7fc00000);

   /// rotation angle in degrees
   /*! \return rotation angle in degrees */
   double deg() const;
   /// rotation angle in radians
   /*! \return rotation angle in radians */
   double rad() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name  */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// Rotation around z
/*! rotate_z is a transformation rotating around the z-axis. Positive angle according to right hand rule.
*/
class rotate_z : public tmatrix
{ 
public: 
   /// constructor (rotate around z)
   /*! \param deg rotation specified in degrees (cannot be combined with rad)
   \param rad rotation specified in radians (cannot be combined with deg) */
   rotate_z(double deg=0x7fc00000, double rad=0x7fc00000);

   /// rotation angle in degrees
   /*! \return rotation angle in degrees */
   double deg() const;
   /// rotation angle in radians
   /*! \return rotation angle in radians */
   double rad() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// Scaling transformation
/*! shape is an abstract base class for all 2d and 3d objects.
*/
class scale : public tmatrix
{ 
public: 
   /// constructor
   /*! \param s scale factor in x,y and z */
   scale(double s);
   /// constructor
   /*! \param sx scale factor in x
   \param sy scale factor in y
   \param sz scale factor in z*/
   scale(double sx, double sy, double sz=1.0);

   /// scale factor in x direction
   /*! \return scale factor in x direction */
   double sx() const;
   /// scale factor in y direction
   /*! \return scale factor in y direction */
   double sy() const;
   /// scale factor in z direction
   /*! \return scale factor in z direction */
   double sz() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// Abstract base for all primitives and booleans
class shape
{ 
public: 
   boundingbox@ box() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
   /// Write to OpenSCAD .csg file
   /*! \param path file path*/
   void write_csg(string path);
   /// Write to AngelCAD .xcsg file
   /*! \param path file path
   \param secant_tolerance tolerance for geometry precision */
   void write_xcsg(string path, double secant_tolerance = - 1.0);
}; 

/// Abstract base for 2d primitives and booleans
/*! shape2d is an abstract base class for all 2d objects.
*/
class shape2d : public shape
{ 
public: 
   boundingbox@ box() const;
   /// Boolean union operator+ overload
   /*! \return resulting 2d shape*/
   shape2d@ opAdd(shape2d@ b);
   /// Boolean intersection operator& overload
   /*! \return resulting 2d shape*/
   shape2d@ opAnd(shape2d@ b);
   /// Boolean difference operator- overload
   /*! \return resulting 2d shape*/
   shape2d@ opSub(shape2d@ b);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
   /// Write to OpenSCAD .csg file
   /*! \param path file path*/
   void write_csg(string path);
   /// Write to AngelCAD .xcsg file
   /*! \param path file path
   \param secant_tolerance tolerance for geometry precision */
   void write_xcsg(string path, double secant_tolerance = - 1.0);
}; 

/// Abstract base for 3d primitives and booleans
/*! solid is an abstract base class for all 3d objects.
*/
class solid : public shape
{ 
public: 
   boundingbox@ box() const;
   /// Boolean union operator+ overload
   /*! \return resulting solid*/
   solid@ opAdd(solid@ b);
   /// Boolean intersection operator& overload
   /*! \return resulting solid*/
   solid@ opAnd(solid@ b);
   /// Boolean difference operator- overload
   /*! \return resulting solid*/
   solid@ opSub(solid@ b);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
   /// Write to OpenSCAD .csg file
   /*! \param path file path*/
   void write_csg(string path);
   /// Write to AngelCAD .xcsg file
   /*! \param path file path
   \param secant_tolerance tolerance for geometry precision */
   void write_xcsg(string path, double secant_tolerance = - 1.0);
}; 

/// sphere, centered at origin
/*! a sphere is a 3d object defined by its radius.
*/
class sphere : public solid
{ 
public: 
   /// constructor
   /*! \param r radius */
   sphere(double r);

   boundingbox@ box() const;
   /// sphere radius
   /*! \return radius */
   double r() const;
   /// sphere radius
   /*! \return radius */
   double radius() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 2d cubic spline curve
/*! a spline2d is a 2d cubic spline curve.
*/
class spline2d
{ 
public: 
   /// constructor
   /*! \param points array of points on the spline curve*/
   spline2d(array<pos2d@>@ points);

   /// class type string
   /*! \return string containing type name */
   string Type() const;
}; 

/// 3d cubic spline curve
/*! a spline3d is a 3d cubic spline curve.
*/
class spline3d
{ 
public: 
   /// constructor
   /*! \param points array of points on the spline curve*/
   spline3d(array<pos3d@>@ points);

   /// class type string
   /*! \return string containing type name */
   string Type() const;
}; 

/// spline_path for sweep
/*! a spline_path defines a cubic spline sweep path.
*/
class spline_path
{ 
public: 
   /// constructor
   /*! \param p array of points on the spline sweep curve
   \param v array of "up" vectors orienting the sweep profile, 'v' must have same length as 'p'. */
   spline_path(array<pos3d@>@ p, array<vec3d@>@ v);
   /// constructor
   /*! \param p array of points on the spline sweep curve
   \param v single "up" vector orienting the sweep profile for all points */
   spline_path(array<pos3d@>@ p, vec3d@ v);

   /// class type string
   /*! \return string containing type name */
   string Type() const;
}; 

/// square, by default located in 1st quadrant touching origin
/*! a square is a 2d quadrilateral with equal dimensions in x and y.
By default it touches the origin and extend along positive x and y.
*/
class square : public shape2d
{ 
public: 
   /// constructor
   /*! \param size extent in x and y
   \param center true if square to be centered on origon */
   square(double size, bool center=false);

   boundingbox@ box() const;
   /// size of square
   /*! \return size of square */
   double size() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
}; 

class string
{ 
public: 
   bool empty() const;
   bool isEmpty() const;
   bool opEquals(const string&in) const;
   const uint8& opIndex(uint) const;
   int find(const string&in, uint start = 0) const;
   int findFirst(const string&in, uint start = 0) const;
   int findLast(const string&in, int start = - 1) const;
   int opCmp(const string&in) const;
   int rfind(const string&in, int start = - 1) const;
   string substr(uint start = 0, int count = - 1) const;
   string& opAssign(bool);
   string& opAssign(const string&in);
   string& opAssign(double);
   string& opAssign(float);
   string& opAssign(int64);
   string& opAssign(uint64);
   uint get_length() const;
   uint length() const;
   uint size() const;
   uint8& opIndex(uint);
   void resize(uint);
   void set_length(uint);
}; 

/// Sweep 2d shape along path curve to create 3d solid
/*! a sweep creates a solid by sweeping a 2d profile along a path curve
*/
class sweep : public solid
{ 
public: 
   /// constructor
   /*! \param shape 2d profile shape to sweep
   \param path  The path cirve to sweep along */
   sweep(const shape2d@ shape,const spline_path@ path);

   /// return bounding box
   /*! \return The bounding box of the sweep*/
   boundingbox@ box() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Abstract base matrix for transformations
/*! a tmatrix an abstract base class for all transformations.
*/
class tmatrix
{ 
public: 
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// Extrude from botton to top shapes using transform
/*! transform_extrude is a special extrision operation, defined by two 2d shapes,
representing bottom and top of extrusion.
*/
class transform_extrude : public solid
{ 
public: 
   transform_extrude(const shape2d@ bottom, const shape2d@ top);

   boundingbox@ box() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   tmatrix@ transform() const;
}; 

/// Translation in x, y and z
/*! translate is a transformation translating a 2d or 3d object.
*/
class translate : public tmatrix
{ 
public: 
   /// constructor
   /*! \param dx translation in x direction
   \param dy translation in y direction
   \param dz translation in z direction */
   translate(double dx, double dy, double dz=0.0);

   /// translation in x direction
   /*! \return translation in x direction */
   double dx() const;
   /// translation in y direction
   /*! \return translation in y direction */
   double dy() const;
   /// translation in z direction
   /*! \return translation in z direction */
   double dz() const;
   pos2d@ opMul(pos2d@ obj);
   /// transform a point: pos3d@ p = T*obj;
   /*! \param obj position to be transformed
   \return transformed position */
   pos3d@ opMul(pos3d@ obj);
   pos3d@ origin() const;
   /// transform a 2d shape: shape2d@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   shape2d@ opMul(shape2d@ obj);
   /// transform a solid: solid@ s = T*obj;
   /*! \param obj object to be transformed
   \return transformed object */
   solid@ opMul(solid@ obj);
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// matrix multiplication: A = T*B
   /*! \param B matrix to be post-multiplied with this matrix
   \return resulting matrixt */
   tmatrix@ opMul(const tmatrix@ B);
   vec3d@ xdir() const;
   vec3d@ ydir() const;
   vec3d@ zdir() const;
   /// dump matrix to console
   void dump() const;
}; 

/// 2d union boolean operation
/*! union2d is a 2-dimensional boolean operation. It can be invoked either
explicitly or using + operator:
\n\n explicit: shape2d@ object = union2d(circle(100),translate(75,0,0)*circle(50));
\n\n using & operator: shape2d@ object = circle(100) + translate(75,0,0)*circle(50);
*/
class union2d : public shape2d
{ 
public: 
   /// constructor
   /*! \param arr array of 2d shapes  */
   union2d(array<shape2d@>@ arr);
   /// constructor
   /*! \param s1 2d shape
   \param s2 2d shape   */
   union2d(const shape2d@ s1, const shape2d@ s2 );
   /// constructor
   /*! \param s1 2d shape
   \param s2 2d shape
   \param s3 2d shape   */
   union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3 );
   /// constructor
   /*! \param s1 2d shape
   \param s2 2d shape
   \param s3 2d shape
   \param s4 2d shape   */
   union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4 );
   /// constructor
   /*! \param s1 2d shape
   \param s2 2d shape
   \param s3 2d shape
   \param s4 2d shape
   \param s5 2d shape  */
   union2d(const shape2d@ s1, const shape2d@ s2, const shape2d@ s3, const shape2d@ s4, const shape2d@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

/// 3d union boolean operation
/*! union3d is a 3-dimensional boolean operation. It can be invoked either
explicitly or using + operator:
\n\n explicit: solid@ object = union3d(sphere(100),translate(75,0,0)*sphere(50));
\n\n using & operator: solid@ object = sphere(100) + translate(75,0,0)*sphere(50);
*/
class union3d : public solid
{ 
public: 
   /// union3d constructor
   /*! \param arr array of solids  */
   union3d(array<solid@>@ arr);
   /// constructor
   /*! \param s1 solid
   \param s2 solid   */
   union3d(const solid@ s1, const solid@ s2 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid   */
   union3d(const solid@ s1, const solid@ s2, const solid@ s3 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid
   \param s4 solid   */
   union3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4 );
   /// constructor
   /*! \param s1 solid
   \param s2 solid
   \param s3 solid
   \param s4 solid
   \param s5 solid  */
   union3d(const solid@ s1, const solid@ s2, const solid@ s3, const solid@ s4, const solid@ s5 );

   boundingbox@ box() const;
   /// Object type string
   /*! \return type name string*/
   string Type() const;
   tmatrix@ transform() const;
}; 

class unordered_map
{ 
public: 
   unordered_map<T_key,T_value>@ unordered_map(int&in);
   unordered_map<T_key,T_value>@ unordered_map(int&in, unordered_map<T_key,T_value>@);

   T_value& find(const T_key&in);
   T_value& find(const T_key&in, bool&out);
   bool contains(const T_key&in);
   bool empty();
   bool erase(const unordered_map_iterator<T_key,T_value>&in);
   const T_value& get_opIndex(const T_key&in) const;
   int erase(const unordered_map_iterator<T_key,T_value>&in, const unordered_map_iterator<T_key,T_value>&in);
   int size();
   unordered_map<T_key,T_value>& opAssign(unordered_map<T_key,T_value>@);
   unordered_map<T_key,T_value>& swap(unordered_map<T_key,T_value>&inout);
   unordered_map_iterator<T_key,T_value> begin();
   unordered_map_iterator<T_key,T_value> end();
   unordered_map_iterator<T_key,T_value> find_iterator(const T_key&in);
   void SetDirectcomp(bool);
   void clear();
   void erase(const T_key&in);
   void insert(const T_key&in, const T_value&in);
   void set_opIndex(const T_key&in, const T_value&in);
}; 

class unordered_map_iterator
{ 
public: 
   T_value& current_value();
   T_value& get_value();
   bool IsEnd();
   bool IsValid();
   bool next();
   bool opEquals(const unordered_map_iterator<T_key,T_value>&in);
   bool opPostInc();
   bool opPreInc();
   const T_key& current_key();
   const T_key& get_key();
   unordered_map_iterator<T_key,T_value>& opAssign(const unordered_map_iterator<T_key,T_value>&in);
   void set_value(const T_value&in);
}; 

/// 2d direction vector
/*! vec2d is a 2-dimensional vector offering useful operations such as dot and cross products.
*/
class vec2d
{ 
public: 
   /// constructor
   /*! \param p1 vector start position
   \param p2 vector end position*/
   vec2d(const pos2d@ p1, const pos2d@ p2);
   /// constructor
   /*! \param x vector x component
   \param y vector y component*/
   vec2d(double x,double y);

   /// angle between: double rad = v.angle(other);
   /*! \param other vector to compute angle relative to this
   \return angle value in radians*/
   double angle(const vec2d@ other) const;
   /// cross product: double cp = v.cross(other);
   /*! \param other vector to multiply with
   \return cross product value */
   double cross(const vec2d@ other) const;
   /// dot product: double cp = v.dot(other);
   /*! \param other vector to multiply with
   \return dot product value */
   double dot(const vec2d@ other) const;
   /// length of vector
   /*! \return length of vector */
   double length() const;
   /// vector x component
   /*! \return vector x component */
   double x() const;
   /// vector y component
   /*! \return vector y component */
   double y() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   vec2d@ opMul(double f1);
   vec2d@ opMul_r(double f1);
   /// normalise vector length
   void normalise();
}; 

/// 3d direction vector
/*! vec3d is a 3-dimensional vector offering useful operations such as dot and cross products.
*/
class vec3d
{ 
public: 
   vec3d(const pos3d@ p1, const pos3d@ p2);
   /// constructor
   /*! \param x vector x component
   \param y vector y component
   \param z vector z component */
   vec3d(double x,double y, double z);

   /// angle between: double rad = v.angle(other);
   /*! \param other vector to compute angle relative to this
   \return angle value in radians*/
   double angle(const vec3d@ other) const;
   /// dot product: double cp = v.dot(other);
   /*! \param other vector to multiply with
   \return dot product value */
   double dot(const vec3d@ other) const;
   /// length of vector
   /*! \return length of vector */
   double length() const;
   /// vector x component
   /*! \return vector x component */
   double x() const;
   /// vector y component
   /*! \return vector y component */
   double y() const;
   /// vector z component
   /*! \return vector z component */
   double z() const;
   /// class type string
   /*! \return string containing type name */
   string Type() const;
   /// cross product: double cp = v.cross(other);
   /*! \param other vector to multiply with
   \return cross product value */
   vec3d@ cross(const vec3d@ other) const;
   vec3d@ opMul(double f1);
   vec3d@ opMul_r(double f1);
   /// normalise vector length
   void normalise();
}; 
#endif // ANGELCAD_AUTODOC
