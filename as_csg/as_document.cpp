// BeginLicense:
// Part of: angelcad - script based 3D solid modeller 
// Copyright (C) 2017 Carsten Arnholm
// All rights reserved
//
// This file may be used under the terms of either the GNU General
// Public License version 2 or 3 (at your option) as published by the
// Free Software Foundation and appearing in the files LICENSE.GPL2
// and LICENSE.GPL3 included in the packaging of this file.
//
// This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
// INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE.
// EndLicense:
   
#include "as_document.h"
#include <fstream>
#include <string>
#include <set>
using namespace std;


#include <algorithm>
#include <functional>
#include <cctype>

// trim from start
static inline std::string& ltrim(std::string& s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),   std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string& rtrim(std::string& s) {
    s.erase(std::find_if(s.rbegin(), s.rend(),   std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string& trim(std::string &s) {
    return ltrim(rtrim(s));
}


#include "version.h"

// the ones listed here will NOT be documented
// static set<string> type_filter = {  "string", "array", "complex", "as_reftype", "dictionaryValue", "dictionary", "IStream", "OStream" };
static set<string> type_filter = {  "aatc_funcpointer", "as_reftype", "dictionaryValue", "IStream"  };
static set<string> func_filter = {  "opImplCast", "opCast", "Refcount", "opShl", "opShr" };

// opImplCast will be used as basis for determining the type hierarchy
static set<string> base_filter = { "opImplCast" };

as_document::as_document(asIScriptEngine* engine)
{
   document_types(engine);
}

as_document::~as_document()
{}


void as_document::document_types(asIScriptEngine* engine)
{
   asUINT ntypes = engine->GetObjectTypeCount();
   for(asUINT itype=0; itype<ntypes; itype++) {
      if(asITypeInfo* type = engine->GetObjectTypeByIndex(itype)) {
         string type_name = type->GetName();

         if(type_filter.find(type_name) == type_filter.end()) {

            // insert this type into the colection of types to document
            m_types.insert(make_pair(type_name,as_doc_type(type)));
         }
      }
   }

   resolve_base_types();
}

as_doc_type* as_document::get_type(const string& type_name)
{
   auto i = m_types.find(type_name);
   if(i != m_types.end()) {
      as_doc_type* type = &(i->second);
      return type;
   }
   return 0;
}


void as_document::resolve_base_types()
{
   bool resolved = false;
   while(!resolved){

      size_t ncount = 0;
      for(auto i=m_types.begin(); i!= m_types.end(); i++) {
         as_doc_type& type = i->second;
         if(!type.resolve_base(this))ncount++;
      }
      resolved = (ncount==0);
   }
}


void as_document::write_doc(ostream& out)
{
   out << "#ifndef ANGELCAD_AUTODOC" << endl;
   out << "#define ANGELCAD_AUTODOC" << endl;

   out << "/*" << endl;
   out << "This is AngelCAD autogenerated AngelScript documentation" << endl;
   out << "AngelCAD version: " << AS_CSG_version << endl;
   out << "For language description, see: " << endl;
   out << " * The script language   : http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script.html"<< endl;
   out << " * Script class overview : http://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_class_desc.html "<< endl;
   out << endl;
   out << "Below follows a list of AngelCAD classes in alphabetical order written quasi c++ style" << endl;
   out << "to facilitate using it as direct input to doxygen documentation system."<<endl;
   out << "*/" << endl;

   for(auto i=m_types.begin(); i!=m_types.end(); i++) {
      i->second.write_doc(this, i->first, out);
   }

   out << "#endif // ANGELCAD_AUTODOC" << endl;
}


void as_document::read_doxy(const string& path)
{
   ifstream in(path);
   if(in.is_open()) {

      list<string> comments;

      string line;
      while(std::getline(in,line)) {
         trim(line);
         if(line.length() > 0) {
            if(line.substr(0,8) == "classdoc") {

               // find the class name
               size_t ibeg = line.find_first_not_of(' ',9);
               size_t iend = line.find(':');
               string type_name = line.substr(ibeg,iend-ibeg);

               // add comments to class
               as_doc_type_doxy& doxy = m_types_doxy[type_name];
               doxy.insert_classdoc(comments);

               comments.clear();
            }
            else if(line.substr(0,5) == "class") {

               // find the class name
               size_t ibeg = line.find_first_not_of(' ',6);
               size_t iend = line.find(':');
               string type_name = line.substr(ibeg,iend-ibeg);

               // find the signature (less semi-colon)
               size_t isig  = line.find_first_not_of(' ',iend+1);
               size_t isemi = line.find(';',isig);
               string sig   = line.substr(isig,isemi-isig);

               // add comments to signature
               as_doc_type_doxy& doxy = m_types_doxy[type_name];
               doxy.insert_doc(sig,comments);

               comments.clear();
            }

            else {
               comments.push_back(line);
            }
         }
      }
   }
}

as_doc_type_doxy* as_document::get_doxy(const string& type_name)
{
   auto i =  m_types_doxy.find(type_name);
   if(i != m_types_doxy.end()) {
      return &(i->second);
   }
   return 0;
}
